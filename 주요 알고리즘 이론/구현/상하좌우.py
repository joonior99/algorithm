// '구현'이란 '머릿 속에 있는 알고리즘을 소스코드로 바꾸는 과정'이다
// 구현하기 어려운 문제란, 알고리즘은 간단한데 코드가 지나칠 만큼 길어지는 문제, 특정 소수점 자리까지 출력해야 하는 문제, 문자열이 입력으로 주어질 때 한 문자 단위로 끊어서 리스트에 넣어야 하는(파싱을 해야 하는) 문제 등이다
// 완전 탐색, 시뮬레이션 유형을 모두 '구현' 유형으로 묶어서 다루고 있다
// '완전 탐색'은 모든 경우의 수를 주저 없이 다 계산하는 방법
// '시뮬레이션'은 문제에서 제시한 알고리즘을 한 단계씩 차례대로 직접 수행해야 하는 문제 유형

// 상하좌우

// 여행가 A는 N X N 크기의 정사각형 공간 위에 서 있으며 이 공간은 1 X 1 크기의 정사각형으로 나누어져 있다
// 가장 왼쪽 위 좌표는 (1, 1), 가장 오른쪽 아래 좌표는 (N, N)이다
// 상, 하, 좌, 우 방향으로 이동할 수 있으며, 시작 좌표는 항상 (1, 1)이다
// L: 왼쪽으로 한 칸 이동, R: 오른쪽으로 한 칸 이동, U: 위로 한 칸 이동, D: 아래로 한 칸 이동
// 여행가 A가 N X N 크기의 정사각형 공간을 벗어난 움직임은 무시된다
// 계획서가 주어졌을 때 여행가 A가 최종적으로 도착할 지점의 좌표를 출력하는 프로그램을 작성하시오

// 연산 횟수는 이동 횟수에 비례하게 되며, 이동 횟수가 N번인 경우 시간 복잡도는 O(N)이다
// 일련의 명령에 따라 개체를 차례대로 이동시킨다는 점에서 시뮬레이션 유형으로 분류된다

n = int(input())
x, y = 1, 1
plans = input().split()

// L, R, U, D에 따른 이동 방향
dx = [0, 0, -1, 1]
dy = [-1, 1, 0, 0]
move_types = ['L', 'R', 'U', 'D']

for plan in plans: // 이동 계획을 하나씩 확인
  for i in range(len(move_types)): // 이동 후 좌표 구하기
    if plan == move_types[i]:
      nx = x + dx[i]
      ny = y + dy[i]
  
  if nx < 1 or ny < 1 or nx > n or ny > n: // 공간을 벗어나는 경우 무시
    continue
  x, y = nx, ny // 이동 수행
  
print(x, y)
